SOLTION 1: 

FIND DUPLICATE NUMBER.

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n=nums.size();int ans=0;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n;i++){
            if(nums[i]==nums[i+1]){
                ans=nums[i];
            }
        }
        return ans;
    }
};

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOUTION 2:

SORT COLOR.

class Solution {
public:
    void sortColors(vector<int>& nums) {
        // sort(nums.begin(),nums.end());
        int n=nums.size();
        for(int i=0;i<n;i++){
            for(int j=0;j<n-i-1;j++){
                if(nums[j] > nums[j+1]){
                    swap(nums[j],nums[j+1]);
                }
            }
        }
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 3: 

REMOVE DUPLICATES FROM SORTED ARRAY.

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n=nums.size();
        int j=0;
        for(int i=0;i<n;i++){
            if(nums[i]!=nums[j]){
                j++;
                nums[j]=nums[i];
            }
        }
        return j+1;
    }
};

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 4:

SET MATRIX ZERO.

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
       int m=matrix.size();
       int n=matrix[0].size();
       int x=1;
       int y=1;
       for(int j=0;j<n;j++){
           if(matrix[0][j]==0)x=0;
       }
       for(int i=0;i<m;i++){
           if(matrix[i][0]==0)y=0;
       }
       for(int i=1;i<m;i++){
           for(int j=1;j<n;j++){
               if(matrix[i][j]==0){
                   matrix[0][j]=0;
                   matrix[i][0]=0;
               }
           }
       }
       for(int j=1;j<n;j++){
           if(matrix[0][j]==0){
               for(int i=1;i<m;i++){
                   matrix[i][j]=0;
               }
           }
       }
       for(int i=1;i<m;i++){
           if(matrix[i][0]==0){
               for(int j=1;j<n;j++){
                   matrix[i][j]=0;
               }
           }
       }
       if(y==0){
           for(int j=0;j<n;j++){
               matrix[0][j]=0;
           }
       }
       if(x==0){
           for(int i=0;i<m;i++){
               matrix[i][0]=0;
           }
       }
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 5:

MOVE ZEROES.

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int nonZero=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i] != 0){
                swap(nums[i],nums[nonZero]);
                nonZero++;
            }
        }
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 6:

BUY AND SELL (1) .

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int mini=INT_MAX;
        int max_profit=0;
        for(int i=0;i<prices.size();i++){
        if(prices[i] < mini){
            mini=prices[i];
        }
        else if(prices[i]-mini>max_profit){
            max_profit=prices[i]-mini;
        }
    }
     return max_profit;
    }
};

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 7:

CHOCOLATE DISTRIBUTION PROBLEM .

class Solution{
public:
long long findMinDiff(vector<long long> a, long long n, long long m){
        
        sort(a.begin(),a.end());
        int i=0;
        int j=i+m-1;
        long long int mini=INT_MAX;
        while(j < n){
            long long int diff = a[j] - a[i];
            mini=min(diff,mini);
            i++;j++;
        }
        return mini;
    } 
};

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 8:

TWO SUM .

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n=nums.size();
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(nums[i]+nums[j]==target){
                    return {i,j};
                }
            }
        }
        return {};
    }
};

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 9:

BUY AND SELL STOCK (II) .

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        int total_profit=0;
        if(n<=1){
            return 0;
        }
        for(int i=1;i<n;i++){
            if(prices[i] > prices[i-1]){
                total_profit += prices[i] - prices[i-1];
            }
        }
        return total_profit;
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 10: 

FIND ALL DUPLICATES IN ARRAY .

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        int n=nums.size()-1;
        vector<int>ans;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n;i++){
            if(nums[i] == nums[i+1]){
                ans.push_back(nums[i]);
            }
        }
        return ans;
    }
};

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 11:

SUBARRAY SUMS DIVISIBLE BY K .

class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int sum=0;
        int ans=0;
        unordered_map<int,int> mp;
        mp[0]++;
        for(int i=0;i<nums.size();i++)
        {
            sum+=nums[i];
            int rem=sum%k;
            if(rem<0)
            {
                rem+=k;
            }
            ans+=mp[rem];
            mp[rem]++;
        }
        return ans;
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 12:

MERGE SORTED ARRAY .

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) 

          // USING TWO POINTERS
   {
        int i=m-1;
        int j=n-1;
        int k=m+n-1;
        while( j >= 0 ){
            if( i >= 0 && nums1[i] > nums2[j]){
                nums1[k--]=nums1[i--];
            }
            else{
                nums1[k--]=nums2[j--];
            }
        }
    }

           // USING STL

    //    {
    //     int n=nums.size();
    //     for(int i=m,j=0;j<n;j++){
    //         nums1[i++]=nums2[j];
    //     }
    //     sort(nums1.begin(),nums1.end());
    // }

};

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 13:

CONTAINER WITH MOST WATER .

class Solution {
public:
    int maxArea(vector<int>& height) {
        int area=0;
        int maxarea=0;
        int l=0;
        int r=height.size()-1;
        while(l < r){
            area=min(height[l],height[r])*(r-l);
            if(area > maxarea){
                maxarea=area;
            }
            if(height[l] < height[r]){
                l++;
            }
            else{
                r--;
            }
        }
        return maxarea;
    }  
};

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 14:

class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n=cardPoints.size();
        int sum=0;
        for(int i=0;i<n;i++){
            sum+=cardPoints[i];
        }
         int ans;
        int window=0;
        if(n==k){
            return sum;
        }
        for(int i=0;i<n-k-1;i++){
            window+=cardPoints[i];
        }
        for(int i=n-k-1;i<n;i++){
            window+=cardPoints[i];
            ans=max(ans,sum-window);
            window-=cardPoints[i-(n-k-1)];
        }
        return ans;
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 15: 

ALL UNIQUE PERMUTATION OF AN ARRAY.

class Solution {
public:
 set<vector<int>> St;
   vector<vector<int>> ans;
       void helper(int ind , int n, vector<int> arr){
            if(ind == n){
               St.insert(arr);
          }
          else{
          for(int i=ind; i<n; i++){
             swap(arr[ind], arr[i]);
             helper(ind+1, n, arr);
             swap(arr[ind], arr[i]);
          }
        }
      }
vector<vector<int>> uniquePerms(vector<int> &arr ,int n){
         helper(0,n,arr);
           for(auto x : St)
            ans.push_back(x);
         return ans;
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 16:

MAXIMUM SUBARRAY SUM (KADANE'S ALGO).

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxsum=INT_MIN;
        int currentsum=0;
        for(int i=0;i<nums.size();i++){
            currentsum+=nums[i];
            if(currentsum > maxsum)
            {
                maxsum=max(currentsum,maxsum);
            }
            if(currentsum < 0){
                currentsum=0;
            }
        }
        return maxsum;   
    }
};

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SOLUTION 17:

ROTATE ARRAY . 

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        reverse(nums.begin(),nums.end());
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

